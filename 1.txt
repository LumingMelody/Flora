明白了，让我重新梳理：

  核心设计

  1. TreeContextResolver 提供统一的参数解析能力 - 供 MCPActor、CapabilityExecutor 等所有执行层使用
  2. 传递完整上下文快照 - 不做预筛选
  3. 引用解析需要优化 - 避免 LLM 逐个展开

  ---
  引用解析的问题

  当前如果传递引用，LLM 看到的是：
  {
    "user_profile": {"$ref": "step_1.result.profile"},
    "orders": {"$ref": "step_2.result.orders"}
  }

  LLM 不知道里面有什么，必须一个个展开才能判断是否需要 → 消耗大

  ---
  优化方案：Schema 摘要 + 按需展开

  传递的不是纯引用，而是 带 Schema 摘要的引用：

  context_snapshot = {
      "step_1": {
          "_schema": {
              "user_id": "string",
              "profile": {
                  "name": "string",
                  "age": "int",
                  "preferences": "list[string]"
              }
          },
          "_ref": "step_results.step_1"  # 实际数据的引用
      },
      "step_2": {
          "_schema": {
              "orders": "list[{order_id: string, amount: float, status: string}]",
              "total": "int"
          },
          "_ref": "step_results.step_2"
      }
  }

  LLM 工作流程：
  1. 看 _schema 就知道每个步骤有哪些字段和类型
  2. 决定需要哪些数据（如 step_1.profile.name, step_2.orders）
  3. TreeContextResolver 根据 LLM 的选择，从 _ref 指向的实际数据中提取

  优点：
  - LLM 只需看 Schema 摘要，不需要展开完整数据
  - Schema 很小，token 消耗低
  - 实际数据按需提取，精确高效

  ---
  TreeContextResolver 增强

  class TreeContextResolver:
      def resolve_params_for_tool(
          self,
          tool_schema: dict,           # 工具的参数定义
          context_snapshot: dict,      # 带 Schema 摘要的上下文
          step_results: dict           # 实际数据存储
      ) -> dict:
          """
          1. 将 tool_schema 和 context_snapshot._schema 交给 LLM
          2. LLM 返回参数映射：{"user_id": "step_1.user_id", "name": "step_1.profile.name"}
          3. 根据映射从 step_results 提取实际值
          """
          # Step 1: LLM 决定参数来源（只看 schema，不看数据）
          param_mapping = self._llm_resolve_mapping(tool_schema, context_snapshot)

          # Step 2: 按映射提取实际值
          resolved = {}
          for param_name, path in param_mapping.items():
              resolved[param_name] = self._extract_by_path(step_results, path)

          return resolved

      def _build_schema_summary(self, data: Any) -> dict:
          """从实际数据自动生成 Schema 摘要"""
          if isinstance(data, dict):
              return {k: self._build_schema_summary(v) for k, v in data.items()}
          elif isinstance(data, list):
              if data:
                  return f"list[{self._build_schema_summary(data[0])}]"
              return "list[]"
          elif isinstance(data, str):
              return "string"
          elif isinstance(data, int):
              return "int"
          elif isinstance(data, float):
              return "float"
          elif isinstance(data, bool):
              return "bool"
          else:
              return type(data).__name__

  ---
  数据流

  TaskGroupAggregator
      │
      │ 每步执行完后：
      │   1. 存储完整结果到 step_results[step_id]
      │   2. 生成 schema 摘要存入 context_snapshot[step_id]._schema
      │
      ▼
  MCPActor / CapabilityExecutor
      │
      │ 调用 TreeContextResolver.resolve_params_for_tool()
      │   - 输入：tool_schema + context_snapshot (只有 schema)
      │   - LLM 决定映射
      │   - 按映射从 step_results 提取实际值
      │
      ▼
  实际工具调用（参数已解析）
